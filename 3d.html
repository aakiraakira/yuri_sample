<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D Ring Carousel – Reputifly</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0b0d10;            /* page background */
      --fg:#eaeaea;            /* text color */
      --muted:#9aa3ad;
      --card-w: 230px;         /* card size */
      --card-h: 340px;
      --radius3d: 540px;       /* ring radius (controls spacing depth) */
      --tilt: 0deg;            /* extra tilt for center (kept 0 for flat front) */
      --focus-scale: 1.10;     /* center scale */
      --shadow: 0 18px 40px rgba(0,0,0,.35);
      --perspective: 1200px;   /* camera distance */
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--fg);
      font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display:flex; align-items:center; justify-content:center; padding:32px; overflow-x:hidden;
    }

    .wrap{width:min(1200px, 100%);}    
    .headline{ text-align:center; margin-bottom:18px; }
    .headline h1{margin:.2rem 0; font-size:clamp(1.4rem, 2.2vw, 2.2rem)}
    .headline p{margin:.2rem 0; color:var(--muted)}

    /* ===== Ring Carousel ===== */
    .carousel{ position:relative; width:100%; padding: 30px 0 80px; }
    .viewport{ height:var(--card-h); perspective: var(--perspective); position:relative; }

    .deck{ position:absolute; top:50%; left:50%; width:1px; height:1px;
      transform-style:preserve-3d; will-change:transform;
      transform: translate3d(-50%,-50%, calc(-1 * var(--radius3d))) rotateY(calc(var(--rot, 0deg)));
      /* This transition is now *only* applied by JavaScript when needed,
        not all the time.
      */
    }

    .card{
      position:absolute; top:50%; left:50%; width:var(--card-w); height:var(--card-h);
      border-radius:18px; overflow:hidden; background:#111; box-shadow:var(--shadow);
      transform-style:preserve-3d; user-select:none; -webkit-user-drag:none; cursor:pointer;
      /*
        Card transitions are separate, so they can fade/scale while
        the deck rotation is being dragged (which has no transition).
      */
      transition: transform .6s cubic-bezier(.16,1,.3,1), filter .6s ease, opacity .6s ease;
    }
    .card img{ width:100%; height:100%; object-fit:cover; display:block; pointer-events:none; }

    /* Soft ground glow */
    .floor{ position:absolute; left:0; right:0; bottom:-6px; height:70px; pointer-events:none; }
    .floor::before{ content:""; position:absolute; inset:0; transform: translateY(36px);
      background: radial-gradient(120% 100% at 50% 0%, rgba(255,255,255,.12), transparent 60%);
      filter: blur(8px);
    }

    /* Navigation */
    .nav{ position:absolute; inset:0; display:flex; align-items:center; justify-content:space-between; pointer-events:none; }
    .btn{ pointer-events:auto; width:44px; height:44px; border-radius:999px; border:1px solid rgba(255,255,255,.22);
      background: rgba(255,255,255,.06); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
      display:grid; place-items:center; cursor:pointer; color:#fff; transition: transform .2s ease, background .2s ease; }
    .btn:hover{ transform: translateY(-1px); background: rgba(255,255,255,.12); }
    .btn svg{ width:22px; height:22px; }

    /* Dots */
    .dots{ position:absolute; left:50%; bottom:8px; transform:translateX(-50%); display:flex; gap:8px; }
    .dot{ width:8px; height:8px; border-radius:50%; background:rgba(255,255,255,.28); }
    .dot.is-active{ background:#fff; }

    /* Responsive */
    @media (max-width: 940px){ :root{ --card-w: 200px; --card-h: 300px; --radius3d: 500px; } }
    @media (max-width: 720px){ :root{ --card-w: 170px; --card-h: 260px; --radius3d: 430px; } }
    @media (max-width: 560px){ :root{ --card-w: 150px; --card-h: 230px; --radius3d: 400px; } }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="headline">
      <h1>3D Coverflow Carousel</h1>
      <p>Evenly spaced, true 3D ring. Autoplay, drag, arrows, keyboard.</p>
    </div>

    <section class="carousel" aria-roledescription="carousel" aria-label="3D Ring Coverflow">
      <div class="viewport">
        <div class="deck" id="deck"></div>
        <div class="floor"></div>
        <div class="nav">
          <button class="btn" id="prev" aria-label="Previous">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 18l-6-6 6-6"/></svg>
          </button>
          <button class="btn" id="next" aria-label="Next">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 6l6 6-6 6"/></svg>
          </button>
        </div>
        <div class="dots" id="dots" aria-hidden="true"></div>
      </div>
    </section>
  </div>

  <script>
    // === Your images (evenly spaced on the ring) ===
    const IMAGES = [
      'https://reputifly.com/wp-content/uploads/2025/10/6278159464611384170.jpg',
      'https://reputifly.com/wp-content/uploads/2025/10/6278159464611384168.jpg',
      'https://reputifly.com/wp-content/uploads/2025/10/6278159464611384165.jpg',
      'https://reputifly.com/wp-content/uploads/2025/10/6278159464611384166.jpg',
      'https://reputifly.com/wp-content/uploads/2025/10/6278159464611384169.jpg',
      'https://reputifly.com/wp-content/uploads/2025/10/6278159464611384172.jpg',
      'https://reputifly.com/wp-content/uploads/2025/10/6278159464611384173.jpg',
      'https://reputifly.com/wp-content/uploads/2025/10/6278159464611384171.jpg'
    ];

    const deck = document.getElementById('deck');
    const dots = document.getElementById('dots');
    const prevBtn = document.getElementById('prev');
    const nextBtn = document.getElementById('next');

    const N = IMAGES.length;
    const step = 360 / N; // even angular spacing
    
    // Build cards
    const cards = IMAGES.map((src, i) => {
      const el = document.createElement('figure');
      el.className = 'card';
      el.setAttribute('role','group');
      el.setAttribute('aria-label', `${i+1} of ${N}`);
      el.innerHTML = `<img src="${src}" alt="Carousel image ${i+1}">`;
      deck.appendChild(el);
      return el;
    });

    // Build dots
    const dotEls = IMAGES.map((_, i) => {
      const d = document.createElement('div');
      d.className = 'dot'; 
      d.addEventListener('click', ()=> goTo(i)); 
      dots.appendChild(d); 
      return d;
    });

    // === State variables ===
    let dragging = false, startX = 0, startRot = 0, lastT = 0, lastX = 0;
    let rotVelocity = 0;      // Rotational velocity (deg/ms)
    let currentRot = 0;       // The deck's current rotation (degrees). THIS IS THE SOURCE OF TRUTH.
    let rafId = null;         // requestAnimationFrame ID
    let lastFrameT = 0;       // Timestamp of the last animation frame
    
    const DAMPING = 0.95;     // Friction factor (0.9 = high friction, 0.99 = low)
    const STOP_THRESHOLD = 0.05; // Min rotational velocity (deg/ms) to stop
    const pxPerStep = 260;    // ~pixels to move 1 card
    const degPerPx = step / pxPerStep; // map drag distance to degrees

    // === Core Functions ===

    /**
     * Calculates the shortest angle between two angles (a - b).
     */
    function shortestAngle(a, b){
      let d = (a - b) % 360; 
      if(d < -180) d += 360; 
      if(d > 180) d -= 360; 
      return d;
    }

    /**
     * The single function to update all visual styles based on `currentRot`.
     */
    function updateLayout(animated=true) {
      // Set transition style for the deck itself
      deck.style.transition = animated ? 'transform .6s cubic-bezier(.16,1,.3,1)' : 'none';
      
      // Apply the deck rotation
      deck.style.setProperty('--rot', currentRot + 'deg');
      
      const frontAng = -currentRot; // The angle currently facing the user
      const rad = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--radius3d'));
      const focus = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--focus-scale'));
      
      // Update each card's transform, filter, and opacity
      cards.forEach((card, i)=>{
        const ang = i * step; // Card's fixed position in the ring
        const rel = shortestAngle(ang, frontAng); // How far from the front?
        const closeness = 1 - Math.min(Math.abs(rel)/90, 1); // 0..1 within ±90°
        
        const sc = 0.84 + closeness * (focus - 0.84);
        const blur = (1 - closeness) * 0.6;
        
        card.style.transform = `translate(-50%,-50%) rotateY(${ang}deg) translateZ(${rad}px) scale(${sc})`;
        card.style.filter = `brightness(${0.82 + closeness*0.25}) blur(${blur}px)`;
        card.style.opacity = String(0.55 + closeness*0.45);
        card.style.zIndex = String(1000 + Math.round(closeness*100));
      });
      
      // Update dots
      const snappedIndex = (Math.round((-currentRot) / step) % N + N) % N;
      dotEls.forEach((d, i)=> d.classList.toggle('is-active', i === snappedIndex));
    }

    /**
     * Animates to a specific card index using the shortest path.
     */
    function goTo(i){ 
      const newIndex = (i % N + N) % N;
      const targetRot = -newIndex * step; // Canonical rotation for this index
      
      // *** INFINITE LOOP FIX ***
      // Find the closest equivalent rotation to our *current* rotation
      const diff = targetRot - currentRot;
      const shortestDiff = (diff + 180 + 3600) % 360 - 180; // (3600 to ensure positive)
      
      currentRot = currentRot + shortestDiff; // This is our new *target*
      
      updateLayout(true); // Animate to the new position
      resetAutoplay(); 
    }

    // === Event Handlers ===

    // Buttons
    const next = ()=> {
      const snappedIndex = (Math.round((-currentRot) / step) % N + N) % N;
      goTo(snappedIndex + 1);
    };
    const prev = ()=> {
      const snappedIndex = (Math.round((-currentRot) / step) % N + N) % N;
      goTo(snappedIndex - 1);
    };
    nextBtn.addEventListener('click', next);
    prevBtn.addEventListener('click', prev);


    // --- Pointer Drag / Scroll ---
    deck.addEventListener('pointerdown', (e)=>{
      cancelAnimationFrame(rafId); // Stop any coasting animation
      rafId = null;
      
      // *** "STUCK" BUG FIX ***
      // Stop any CSS snap and get the *actual* current visual rotation
      deck.style.transition = 'none';
      const styles = getComputedStyle(deck);
      // Read the transform matrix
      const matrix = new DOMMatrix(styles.transform); 
      // Get the rotateY angle from the matrix (atan2(m13, m11))
      currentRot = Math.atan2(matrix.m13, matrix.m11) * (180 / Math.PI);
      // *** END FIX ***
      
      dragging=true; 
      startX=lastX=e.clientX; 
      lastT=performance.now();
      startRot = currentRot; // Start from the *actual* visual rotation
      
      stopAutoplay(); 
      deck.setPointerCapture(e.pointerId);
      rotVelocity = 0;
    });
    
    deck.addEventListener('pointermove', (e)=>{
      if(!dragging) return; 
      const now = performance.now(); 
      const dx = e.clientX - lastX; 
      const dt = now - lastT || 16; // ms since last move
      
      const newRot = startRot + (e.clientX - startX) * degPerPx;
      const dRot = newRot - currentRot; // Change in rotation
      
      rotVelocity = dRot/dt;  // deg/ms
      
      lastX = e.clientX; 
      lastT = now;
      currentRot = newRot; // Update current rotation
      
      updateLayout(false); // Update styles (no animation)
    });

    const endDrag = (e)=>{
      if(!dragging) return; 
      dragging=false; 
      deck.releasePointerCapture?.(e.pointerId);
      
      // Clamp velocity to prevent insane flings
      rotVelocity = Math.max(-1.5, Math.min(1.5, rotVelocity));
      
      // Start the coasting animation
      startCoasting();
    };
    deck.addEventListener('pointerup', endDrag);
    deck.addEventListener('pointercancel', endDrag);

    // --- Physics coasting animation ---
    function coast() {
      if (rafId === null) return;
      
      const now = performance.now();
      const dt = now - lastFrameT || 16.67; // ms since last frame
      lastFrameT = now;

      // Apply damping (frame-rate independent)
      rotVelocity *= Math.pow(DAMPING, dt / 16.67);
      
      // Stop if velocity is negligible
      if (Math.abs(rotVelocity) < STOP_THRESHOLD) {
        cancelAnimationFrame(rafId);
        rafId = null;
        // Snap to the nearest index
        const targetIndex = (Math.round((-currentRot) / step) % N + N) % N;
        goTo(targetIndex); // This will animate the snap
        return;
      }

      // Update rotation
      currentRot += rotVelocity * dt;
      updateLayout(false); // Update styles (no animation)
      
      rafId = requestAnimationFrame(coast);
    }

    function startCoasting() {
      cancelAnimationFrame(rafId);
      lastFrameT = performance.now();
      rafId = requestAnimationFrame(coast);
    }

    // --- Keyboard ---
    window.addEventListener('keydown', (e)=>{ 
      if(e.key==='ArrowRight') next(); 
      if(e.key==='ArrowLeft') prev(); 
    });

    // --- Autoplay ---
    let timer=null; const INTERVAL=3000; let paused=false;
    const startAutoplay = ()=>{ if(paused) return; stopAutoplay(); timer = setInterval(next, INTERVAL); };
    const stopAutoplay  = ()=>{ if(timer) clearInterval(timer); timer=null; };
    const resetAutoplay = ()=>{ stopAutoplay(); startAutoplay(); };
    
    deck.addEventListener('mouseenter', ()=>{ paused=true; stopAutoplay(); });
    deck.addEventListener('mouseleave', ()=>{ paused=false; startAutoplay(); });

    // --- Initial Layout ---
    const radius = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--radius3d'));
    // Lay out cards around ring (initial placement)
    cards.forEach((card, i)=>{ 
      card.style.transform = `translate(-50%,-50%) rotateY(${i*step}deg) translateZ(${radius}px)`; 
    });
    
    // Do the first full layout
    currentRot = 0;
    updateLayout(false); // No animation on load
    startAutoplay();

    // Keep layout correct on resize
    window.addEventListener('resize', ()=> updateLayout(false));
  </script>
</body>
</html>
