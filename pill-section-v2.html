<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Deer Placenta Animation</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;800&display=swap" rel="stylesheet">
  
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #f8f8f8; /* Bright background */
      color: #333; /* Darker text for contrast */
      font-family: 'Inter', sans-serif;
      overflow-x: hidden; /* Prevent horizontal scrolling */
    }

    /* ---------- Layout ---------- */
    
    .layout-container {
      display: flex;
      flex-direction: row; /* Default to row for desktop */
      width: 100%;
      min-height: 100vh; /* Minimum viewport height */
      padding: 3rem;
      gap: 3rem; /* Gap between text and right column */
      box-sizing: border-box; /* Include padding in height/width */
    }

    .text-content {
      flex: 1; /* Take up 50% of the space */
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding-right: 2rem;
    }

    /* New container for the right column (animation + 30x) */
    .right-column-container {
      flex: 1; /* Take up 50% of the space */
      display: flex;
      flex-direction: column;
      gap: 2rem; /* Gap between animation and 30x containers */
    }

    .text-content h1 {
      font-size: 3.8rem;
      font-weight: 800;
      margin-bottom: 1.5rem;
      line-height: 1.2;
      background: linear-gradient(45deg, #a00000, #e00000, #ff6a6a);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-fill-color: transparent;
    }

    .text-content p {
      font-size: 1.15rem;
      line-height: 1.7;
      color: #555;
      max-width: 55ch;
    }

    /* Shared style for glass containers */
    .glass-container {
      border-radius: 25px;
      overflow: hidden;
      background: rgba(255, 255, 255, 0.3);
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.4);
    }

    .animation-container {
      flex: 1; /* Make it take up available space */
      position: relative; /* Anchor for scene */
      min-height: 400px; /* Give it a minimum height */
    }

    #scene {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      background: transparent;
      pointer-events: none;
    }

    /* New container for the multiplier */
    .multiplier-container {
      padding: 2.5rem;
      text-align: center;
    }
    
    .multiplier-container .multiplier-label {
      display: flex;
      align-items: baseline;
      justify-content: center;
      gap: 0.5rem;
    }
    
    .multiplier-container span#counter {
      font-size: 4.5rem;
      font-weight: 800;
      line-height: 1;
      display: inline-block;
      color: #c00000;
      -webkit-text-stroke: 1px rgba(0,0,0,0.1);
      text-stroke: 1px rgba(0,0,0,0.1);
    }
    
    .multiplier-container span.multiplier-unit {
      font-size: 3rem;
      font-weight: 700;
      color: #666;
    }
    
    .multiplier-container .label {
      font-size: 1.2rem;
      margin: 0.5rem 0 0 0;
      line-height: 1.3;
      color: #666;
    }

    /* Hide the original UI buttons */
    .ui {
      display: none;
    }

    /* ---------- Mobile Optimization ---------- */
    @media (max-width: 900px) {
      .layout-container {
        flex-direction: column; /* Stack vertically on mobile */
        padding: 2rem 1.5rem;
        gap: 2.5rem;
        min-height: auto;
      }
      
      /* --- NEW MOBILE ORDER --- */
      .text-content {
        order: 3; /* Text is last */
        padding-right: 0;
        text-align: center;
      }
      
      .right-column-container {
        order: 1; /* This whole column (Anim + 30x) is first */
        gap: 1.5rem; /* Reduce gap on mobile */
      }
      /* --- END NEW MOBILE ORDER --- */


      .text-content h1 {
        font-size: 2.5rem;
        margin-bottom: 1rem;
      }

      .text-content p {
        font-size: 1rem;
        max-width: 100%;
      }

      .animation-container {
        min-height: 350px; /* Adjust height for mobile */
        border-radius: 15px;
      }

      .glass-container {
        border-radius: 15px;
      }
      
      .multiplier-container {
        padding: 1.5rem;
      }

      .multiplier-container span#counter {
        font-size: 3.5rem;
      }
      .multiplier-container span.multiplier-unit {
        font-size: 2.5rem;
      }
      .multiplier-container .label {
        font-size: 1rem;
      }
    }
  </style>
</head>
<body>

  <main class="layout-container">
    
    <div class="text-content">
      <h1>The Power of Deer Placenta</h1>
      <p>Discover the rejuvenating properties of one of nature's most potent ingredients. Deer placenta is rich in nutrients and growth factors that support cellular regeneration.</p>
      <p>Experience a new level of wellness and anti-aging, enhancing vitality and promoting radiant, youthful-looking skin.</p>
    </div>

    <div class="right-column-container">
    
      <div class="animation-container glass-container">
        <div id="scene"></div>
      </div>
      
      <div class="multiplier-container glass-container">
        <div class="multiplier-label">
          <span id="counter">0</span><span class="multiplier-unit">X</span>
        </div>
        <p class="label">Cellular Regeneration</p>
      </div>

    </div>

  </main>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script>
  (() => {
    // Counter animation logic
    const counterElement = document.getElementById('counter');
    let animationStarted = false;

    const animateCounter = () => {
      let currentNumber = 0;
      const targetNumber = 30;
      const duration = 2000; // 2 seconds
      const interval = 50; // milliseconds

      const increment = targetNumber / (duration / interval);

      const timer = setInterval(() => {
        currentNumber += increment;
        if (currentNumber >= targetNumber) {
          currentNumber = targetNumber;
          clearInterval(timer);
        }
        counterElement.textContent = Math.floor(currentNumber);
      }, interval);
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && !animationStarted) {
          animateCounter();
          animationStarted = true;
          observer.unobserve(entry.target);
        }
      });
    }, { threshold: 0.5 });

    observer.observe(counterElement);

    // =================================================================
    // START: NEW ANIMATION CODE (REDDER PILL)
    // =================================================================

    // ---------- Renderer ----------
    const host = document.getElementById('scene');
    const scene = new THREE.Scene();

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(host.clientWidth, host.clientHeight); // MOD: Use host size
    renderer.setClearColor(0x000000, 0);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.15;
    renderer.physicallyCorrectLights = true;
    host.appendChild(renderer.domElement);

    // ---------- Camera ----------
    const camera = new THREE.PerspectiveCamera(28, host.clientWidth/host.clientHeight, 0.1, 200); // MOD: Use host aspect
    scene.add(camera);
    function fitCameraToHeight(worldHeight, margin=1.12){
      const h = worldHeight*margin;
      const dist = (h*0.5)/Math.tan(THREE.MathUtils.degToRad(camera.fov*0.5));
      camera.position.set(0, 0.25, dist);
      camera.lookAt(0,0,0);
      camera.updateProjectionMatrix();
    }
    // MOD: Deleted window 'resize' event listener

    // ---------- Lights ----------
    scene.add(new THREE.HemisphereLight(0xffffff, 0x141414, 0.7));
    const key = new THREE.DirectionalLight(0xffffff, 1.25); key.position.set(2.6,3.8,6.3); scene.add(key);
    const fill= new THREE.DirectionalLight(0xffffff, 0.55); fill.position.set(-3.6,1.2,3.4); scene.add(fill);
    const rim = new THREE.DirectionalLight(0xffffff, 0.75); rim.position.set(-2.2,2.0,-5.6); scene.add(rim);

    // ---------- Materials (REDDER, still see-through) ----------
    // Deeper reds + slightly higher opacity for stronger tint.
    const RED_TOP    = 0xcf2323; // redder/brighter top
    const RED_BOTTOM = 0xbf1717; // redder bottom
    const RED_INNER  = 0x7a1010; // darker inner/lip

    // Use transparent blending (not transmission) so overlap is very clear.
    function layeredMat(hex, extra={}) {
      return new THREE.MeshPhysicalMaterial({
        color: hex,
        roughness: 0.2,
        metalness: 0.0,
        transparent: true,
        opacity: 0.34,        // was 0.24 — redder but still see-through
        transmission: 0.0,
        ior: 1.45,
        clearcoat: 0.6,
        clearcoatRoughness: 0.18,
        reflectivity: 0.45,
        side: THREE.DoubleSide,
        depthWrite: false,    // keeps layered overlap readable
        ...extra
      });
    }
    const matTopOuter = layeredMat(RED_TOP);
    const matBotOuter = layeredMat(RED_BOTTOM);
    const matInner    = layeredMat(RED_INNER, { opacity: 0.40 });

    // ---------- Capsule geometry (hollow + rounded lips + sleeve overlap) ----------
    const rTop = 1.20;     // top outer radius
    const rBot = 1.18;     // bottom slightly smaller so it slides into top
    const wall = 0.08;     // wall thickness
    const halfCyl = 2.0;
    const openDistance = 2.8;
    const sleeveDepth = 0.26; // how much the top overlaps the bottom when closed

    const topGroup = new THREE.Group();
    const botGroup = new THREE.Group();
    botGroup.renderOrder = 0;
    topGroup.renderOrder = 1;
    scene.add(topGroup, botGroup);

    const segs = 80;

    // Top outer/inner + rounded lip
    const topOuterCyl = new THREE.Mesh(new THREE.CylinderGeometry(rTop, rTop, halfCyl, segs, 1, true), matTopOuter);
    topOuterCyl.position.y = halfCyl/2; topGroup.add(topOuterCyl);
    const topOuterHem = new THREE.Mesh(new THREE.SphereGeometry(rTop, segs, 48, 0, Math.PI*2, 0, Math.PI/2), matTopOuter);
    topOuterHem.position.y = halfCyl; topGroup.add(topOuterHem);
    const topInnerCyl = new THREE.Mesh(new THREE.CylinderGeometry(rTop-wall, rTop-wall, halfCyl, segs, 1, true), matInner);
    topInnerCyl.position.y = halfCyl/2; topGroup.add(topInnerCyl);
    const topInnerHem = new THREE.Mesh(new THREE.SphereGeometry(rTop-wall, segs, 48, 0, Math.PI*2, 0, Math.PI/2), matInner);
    topInnerHem.position.y = halfCyl; topGroup.add(topInnerHem);
    const lipTop = new THREE.Mesh(new THREE.TorusGeometry(rTop - wall*0.5, wall*0.46, 14, 88), matInner);
    lipTop.rotation.x = Math.PI/2; lipTop.position.y = 0.0 + 0.001; topGroup.add(lipTop);

    // Bottom outer/inner + rounded lip
    const botOuterCyl = new THREE.Mesh(new THREE.CylinderGeometry(rBot, rBot, halfCyl, segs, 1, true), matBotOuter);
    botOuterCyl.position.y = -halfCyl/2; botGroup.add(botOuterCyl);
    const botOuterHem = new THREE.Mesh(new THREE.SphereGeometry(rBot, segs, 48, 0, Math.PI*2, Math.PI/2, Math.PI/2), matBotOuter);
    botOuterHem.position.y = -halfCyl; botGroup.add(botOuterHem);
    const botInnerCyl = new THREE.Mesh(new THREE.CylinderGeometry(rBot-wall, rBot-wall, halfCyl, segs, 1, true), matInner);
    botInnerCyl.position.y = -halfCyl/2; botGroup.add(botInnerCyl);
    const botInnerHem = new THREE.Mesh(new THREE.SphereGeometry(rBot-wall, segs, 48, 0, Math.PI*2, Math.PI/2, Math.PI/2), matInner);
    botInnerHem.position.y = -halfCyl; botGroup.add(botInnerHem);
    const lipBot = new THREE.Mesh(new THREE.TorusGeometry(rBot - wall*0.5, wall*0.46, 14, 88), matInner);
    lipBot.rotation.x = Math.PI/2; lipBot.position.y = -0.0 - 0.001; botGroup.add(lipBot);

    // Start CLOSED in overlapped pose
    topGroup.position.y = -sleeveDepth/2;
    botGroup.position.y =  sleeveDepth/2;

    // Fit camera
    const totalHeight = (halfCyl*2 + rTop*2) + openDistance*2 + 2.0;

    // MODIFICATION: Use ResizeObserver from original file for robust layout resizing
    function onResize() {
      const width = host.clientWidth;
      const height = host.clientHeight;

      if (width === 0 || height === 0) return;

      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
      fitCameraToHeight(totalHeight);
    }
    
    new ResizeObserver(onResize).observe(host);
    onResize(); // Initial call to fit to container

    // ---------- Particles (swirl + return) ----------
    const particleCount = 12000;
    const pGeo = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount*3);
    const velocities = new Float32Array(particleCount*3);
    const life = new Float32Array(particleCount);

    for (let i=0;i<particleCount;i++){
      positions[i*3] = positions[i*3+1] = positions[i*3+2] = 0;
      velocities[i*3] = velocities[i*3+1] = velocities[i*3+2] = 0;
      life[i] = 1; // dead
    }

    pGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    pGeo.setAttribute('aLife', new THREE.BufferAttribute(life, 1));

    const pMat = new THREE.PointsMaterial({
      color: 0x7A1C1C,
      size: 0.05,
      sizeAttenuation: true,
      transparent: true,
      opacity: 0.95,
      depthWrite: false
    });

    const points = new THREE.Points(pGeo, pMat);
    scene.add(points);

    function spawnBurst(count, radius=0.06, speed=2.0){
      let spawned = 0;
      for (let i=0;i<particleCount && spawned<count;i++){
        if (life[i] >= 1){
          const u = Math.random(), v = Math.random();
          const theta = 2*Math.PI*u;
          const phi = Math.acos(2*v - 1);
          const rr = radius*Math.cbrt(Math.random());
          const x = rr*Math.sin(phi)*Math.cos(theta);
          const y = rr*Math.cos(phi);
          const z = rr*Math.sin(phi)*Math.sin(theta);
          const dir = new THREE.Vector3(x, y*0.42, z).normalize();

          positions[i*3]   = x;
          positions[i*3+1] = y;
          positions[i*3+2] = z;

          const vmag = speed*(0.7+Math.random()*0.9);
          velocities[i*3]   = dir.x*vmag;
          velocities[i*3+1] = dir.y*vmag;
          velocities[i*3+2] = dir.z*vmag;

          life[i] = 0; spawned++;
        }
      }
      pGeo.attributes.position.needsUpdate = true;
      pGeo.attributes.aLife.needsUpdate = true;
    }

    // ---------- Timeline ----------
    let playing = false, t = 0;

    const openDelay = 0.8;
    const openTime  = 2.2;  // slower & smoother
    const flowTime  = 3.0;  // swirl time
    const suckTime  = 2.2;  // suction active
    const closeTime = 2.2;  // smooth close
    const totalTime = openDelay + openTime + flowTime + suckTime + closeTime + 0.5;

    const smooth = x => (x<=0?0:x>=1?1:(x*x*x*(x*(x*6-15)+10))); // quintic

    function reset(){
      t = 0;
      // back to overlapped closed pose
      topGroup.position.y = -sleeveDepth/2;
      botGroup.position.y =  sleeveDepth/2;

      for (let i=0;i<particleCount;i++){
        life[i]=1;
        velocities[i*3]=velocities[i*3+1]=velocities[i*3+2]=0;
      }
      pGeo.attributes.aLife.needsUpdate = true;
      playing = false;
    }
    function play(){ reset(); playing = true; }

    // MOD: Removed button listeners as buttons are hidden
    // document.getElementById('play').onclick = play;
    // document.getElementById('replay').onclick = play;
    setTimeout(play, 400);

    // ---------- Loop ----------
    let last = performance.now();
    function loop(now){
      requestAnimationFrame(loop);
      const dt = Math.min((now-last)/1000, 0.033);
      last = now;

      if (playing){
        t += dt;

        const tOpenStart = openDelay;
        const tOpenEnd   = tOpenStart + openTime;
        const tFlowEnd   = tOpenEnd + flowTime;
        const tSuckEnd   = tFlowEnd + suckTime;
        const tCloseEnd  = tSuckEnd + closeTime;

        // Opening — from overlapped closed -> fully open
        if (t >= tOpenStart){
          const kO = smooth(Math.min((t - tOpenStart)/openTime, 1));
          topGroup.position.y = (-sleeveDepth/2) + kO*(openDistance + sleeveDepth/2);
          botGroup.position.y = ( sleeveDepth/2) - kO*(openDistance + sleeveDepth/2);
        }

        // Emit while opening + flow
        if (t > tOpenStart + 0.2 && t < tFlowEnd){
          spawnBurst(520);
        }

        // Closing (starts after flow; suction overlaps) — back to overlapped pose
        if (t > tFlowEnd){
          const kC = smooth(Math.min((t - tFlowEnd)/closeTime, 1));
          topGroup.position.y = openDistance*(1-kC) - (sleeveDepth/2)*kC;
          botGroup.position.y = -openDistance*(1-kC) + (sleeveDepth/2)*kC;
        }

        // MOD: Auto-replay at the end to loop the animation
        if (t >= tCloseEnd || t >= totalTime) {
          play();
        }
      }

      // Particle dynamics — unchanged
      const drag = 0.986;
      const inFlow   = (t > openDelay) && (t < (openDelay+openTime+flowTime));
      const suction  = (t >= (openDelay+openTime+flowTime));
      const swirlGain = inFlow ? 1.15 : 0.55;
      const suctionGain = suction ? 2.6 : 0.0;

      for (let i=0;i<particleCount;i++){
        if (life[i] < 1){
          const ix = i*3;
          let x=positions[ix], y=positions[ix+1], z=positions[ix+2];

          // Swirl around Y axis (vortex)
          const rXZ = Math.max(0.0001, Math.hypot(x,z));
          const tx = (-z / rXZ);
          const tz = ( x / rXZ);
          const swirl = swirlGain*(0.85 + 0.15*Math.random());
          velocities[ix]   += tx*swirl*dt;
          velocities[ix+2] += tz*swirl*dt;

          // Mild gravity
          velocities[ix+1] += -0.24*dt;

          // Suction towards center (return)
          if (suction){
            const toX=-x, toY=-y, toZ=-z;
            const dist = Math.max(0.0001, Math.hypot(toX,toY,toZ));
            const s = suctionGain*dt;
            velocities[ix]   += (toX/dist)*s;
            velocities[ix+1] += (toY/dist)*s;
            velocities[ix+2] += (toZ/dist)*s;

            // Absorb back inside
            if (dist < 0.12){
              life[i] = 1;
              velocities[ix]=velocities[ix+1]=velocities[ix+2]=0;
              continue;
            }
          }

          // Integrate + turbulence + drag
          positions[ix]   += velocities[ix]*dt;
          positions[ix+1] += velocities[ix+1]*dt;
          positions[ix+2] += velocities[ix+2]*dt;

          velocities[ix]   += (Math.random()-0.5)*0.06*dt;
          velocities[ix+1] += (Math.random()-0.5)*0.05*dt;
          velocities[ix+2] += (Math.random()-0.5)*0.06*dt;

          velocities[ix]*=drag; velocities[ix+1]*=drag; velocities[ix+2]*=drag;

          if (!suction){ life[i] += dt*0.18; if (life[i] >= 1) life[i]=1; }
        }
      }
      pGeo.attributes.position.needsUpdate = true;

      renderer.render(scene, camera);
    }
    loop(performance.now());
    
    // =================================================================
    // END: NEW ANIMATION CODE
    // =================================================================

  })();
  </script>
</body>
</html>
