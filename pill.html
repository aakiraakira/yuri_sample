<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Capsule Open â€” 3D Transparent</title>
  <style>
    html,body{height:100%;margin:0;background:transparent}
    #scene{position:fixed;inset:0;background:transparent;pointer-events:none;}
    /* Optional play button */
    .ui {position:fixed; inset:auto 0 24px 0; display:flex; justify-content:center; gap:10px; pointer-events:auto;}
    .btn{font:600 14px/1.1 Inter,system-ui,Arial; padding:12px 16px; border-radius:12px; border:0;
         background:#151515; color:#fff; box-shadow:0 6px 20px rgba(0,0,0,.25); cursor:pointer}
    .btn:active{transform:translateY(1px)}
  </style>
</head>
<body>
  <div id="scene"></div>
  <div class="ui">
    <button id="play" class="btn">Play once</button>
    <button id="replay" class="btn">Replay</button>
  </div>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
  (() => {
    // ----- Core -----
    const host = document.getElementById('scene');
    const scene = new THREE.Scene();

    // Transparent canvas
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.setClearColor(0x000000, 0); // alpha = 0 (transparent)
    host.appendChild(renderer.domElement);

    // ----- ðŸ“¸ CAMERA -----
    let aspect = innerWidth / innerHeight;
    let camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 100);
    camera.position.set(0, 3, 22);
    camera.lookAt(0,0,0);

    // ----- RESIZE -----
    addEventListener('resize', () => {
      aspect = innerWidth / innerHeight;
      camera.aspect = aspect;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // ----- ðŸ’¡ LIGHTING -----
    scene.add(new THREE.AmbientLight(0xffffff, 1.0));
    const key = new THREE.DirectionalLight(0xffffff, 1.5);
    key.position.set(2, 4, 6);
    scene.add(key);
    const rim = new THREE.DirectionalLight(0xffffff, 1.0);
    rim.position.set(-3, 2, -4);
    scene.add(rim);
    const fill = new THREE.DirectionalLight(0xffffff, 0.5);
    fill.position.set(0, -2, 4);
    scene.add(fill);

    // ----- Materials -----
    const CAPSULE_TINT = 0xE02020; // Red capsule tint

    // ----- ðŸŽ¨ PARTICLE COLORS (NEW) -----
    const BROWN = new THREE.Color(0x8B4513);
    const WHITE = new THREE.Color(0xFFFFFF);
    const GREY = new THREE.Color(0x808080);
    const particleColors = [BROWN, WHITE, GREY];

    // ----- ðŸ’Š CAPSULE MATERIAL -----
    const shellMat = new THREE.MeshPhysicalMaterial({
      color: CAPSULE_TINT,
      roughness: 0.02,
      metalness: 0.0,
      transparent: true,
      opacity: 1.0,
      clearcoat: 1,
      clearcoatRoughness: 0.1,
      reflectivity: 0.8,
      transmission: 0.98,
      thickness: 0.1,
      side: THREE.DoubleSide
    });

    // ----- Capsule geometry (two halves) -----
    const r = 1.2;
    const halfCyl = 2.0;
    const openDistance = 2.2;

    const topGroup = new THREE.Group();
    const botGroup = new THREE.Group();
    scene.add(topGroup, botGroup);

    // top cylinder (open-ended)
    const topCyl = new THREE.Mesh(new THREE.CylinderGeometry(r, r, halfCyl, 48, 1, true), shellMat);
    topCyl.position.y = halfCyl/2;
    topGroup.add(topCyl);
    const topHem = new THREE.Mesh(new THREE.SphereGeometry(r, 48, 32, 0, Math.PI*2, 0, Math.PI/2), shellMat);
    topHem.position.y = halfCyl;
    topGroup.add(topHem);

    // bottom cylinder (open-ended)
    const botCyl = new THREE.Mesh(new THREE.CylinderGeometry(r, r, halfCyl, 48, 1, true), shellMat);
    botCyl.position.y = -halfCyl/2;
    botGroup.add(botCyl);
    const botHem = new THREE.Mesh(new THREE.SphereGeometry(r, 48, 32, 0, Math.PI*2, Math.PI/2, Math.PI/2), shellMat);
    botHem.position.y = -halfCyl;
    botGroup.add(botHem);

    // ----- Particle system (MODIFIED FOR MULTI-COLOR) -----
    const particleCount = 1800;
    const pGeo = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const velocities = new Float32Array(particleCount * 3);
    const life = new Float32Array(particleCount);
    const sizes = new Float32Array(particleCount);
    const colorsArray = new Float32Array(particleCount * 3); // <-- NEW color attribute

    for (let i = 0; i < particleCount; i++) {
      positions[i*3] = positions[i*3+1] = positions[i*3+2] = 0;
      velocities[i*3] = velocities[i*3+1] = velocities[i*3+2] = 0;
      life[i] = 1;
      sizes[i] = 10 + Math.random()*10;
      colorsArray[i*3] = colorsArray[i*3+1] = colorsArray[i*3+2] = 0;
    }

    pGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    pGeo.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3)); // <-- SET color attribute
    pGeo.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
    pGeo.setAttribute('aLife', new THREE.BufferAttribute(life, 1));

    // ----- PARTICLE MATERIAL (MODIFIED) -----
    const pMat = new THREE.PointsMaterial({
      size: 0.08, // Slightly larger
      sizeAttenuation: true,
      transparent: true,
      opacity: 1.0,
      depthWrite: false,
      vertexColors: true // <-- CRITICAL: Use the 'color' attribute
    });

    const points = new THREE.Points(pGeo, pMat);
    scene.add(points);

    // ----- PARTICLE SPAWN (MODIFIED FOR COLOR & HELIX) -----
    function spawnBurst(count, spawnRadius = 0.8, spawnHeight = 0.2, initialSpeed = 1.5, spinSpeed = 3.0) {
      let spawned = 0;
      for (let i = 0; i < particleCount && spawned < count; i++) {
        if (life[i] >= 1) {
          const angle = Math.random() * Math.PI * 2;
          const dist = Math.sqrt(Math.random()) * spawnRadius; // Wider radius
          const x = dist * Math.cos(angle);
          const z = dist * Math.sin(angle);
          const y = (Math.random() - 0.5) * spawnHeight;

          positions[i*3] = x;
          positions[i*3+1] = y;
          positions[i*3+2] = z;

          const outwardDir = new THREE.Vector3(x, 0, z).normalize().multiplyScalar(initialSpeed * (0.6 + Math.random() * 0.8)); // More horizontal
          const tangentialDir = new THREE.Vector3(-z, 0, x).normalize().multiplyScalar(spinSpeed * (0.5 + Math.random() * 1.0));

          velocities[i*3] = outwardDir.x + tangentialDir.x;
          velocities[i*3+1] = (Math.random() - 0.5) * 2.0; // <-- NEW: Initial Y-velocity for bounce
          velocities[i*3+2] = outwardDir.z + tangentialDir.z;

          life[i] = 0;
          sizes[i] = 10 + Math.random()*14;
          
          // --- Assign random color ---
          const c = particleColors[Math.floor(Math.random() * particleColors.length)];
          colorsArray[i*3] = c.r;
          colorsArray[i*3+1] = c.g;
          colorsArray[i*3+2] = c.b;

          spawned++;
        }
      }
      pGeo.attributes.position.needsUpdate = true;
      pGeo.attributes.aLife.needsUpdate = true;
      pGeo.attributes.aSize.needsUpdate = true;
      pGeo.attributes.color.needsUpdate = true; // <-- NEW: Update color buffer
    }

    // ----- ðŸŒ€ ANIMATION (NEW STATE MACHINE) ðŸŒ€ -----
    let playing = false;
    let t = 0;
    let animState = 'IDLE';

    const openDelayTime = 0.5;
    const openTime = 1.8;
    const swirlTime = 5.0;   // Longer swirl
    const reverseTime = 2.5; // Longer pack-in
    const closeTime = 1.8;

    const easeInOut = (x)=> (x<0.5) ? 2*x*x : 1 - Math.pow(-2*x+2,2)/2;

    // Controls
    document.getElementById('play').onclick = () => {
      if (animState === 'IDLE') play();
    };
    document.getElementById('replay').onclick = () => {
      if (animState === 'IDLE' || !playing) play();
    };

    function play() {
      reset();
      playing = true;
      animState = 'OPENING';
      t = 0;
    }

    function reset() {
      t = 0;
      topGroup.position.y = 0;
      botGroup.position.y = 0;
      for (let i=0;i<particleCount;i++){
        life[i]=1;
        positions[i*3] = positions[i*3+1] = positions[i*3+2] = 0;
      }
      pGeo.attributes.aLife.needsUpdate = true;
      pGeo.attributes.position.needsUpdate = true;
      animState = 'IDLE';
      playing = false;
    }
    
    // Auto-play
    setTimeout(play, 400);

    // ----- Render loop (NEW "HELIX" PHYSICS) -----
    let last = performance.now();
    function loop(now){
      requestAnimationFrame(loop);
      const dt = Math.min((now-last)/1000, 0.033);
      last = now;

      if (playing) {
        t += dt;

        // --- State Machine ---
        if (animState === 'OPENING') {
          if (t > openDelayTime) {
            const k = Math.min((t - openDelayTime) / openTime, 1);
            const e = easeInOut(k);
            topGroup.position.y = e * openDistance;
            botGroup.position.y = -e * openDistance;
            
            if (k > 0.1) { spawnBurst(80); }
            if (k >= 1) { t = 0; animState = 'SWIRLING'; }
          }
        } 
        else if (animState === 'SWIRLING') {
          spawnBurst(80);
          if (t > swirlTime) { t = 0; animState = 'REVERSING'; }
        } 
        else if (animState === 'REVERSING') {
          if (t > reverseTime) {
            t = 0;
            animState = 'CLOSING';
            for (let i=0; i<particleCount; i++) { life[i] = 1; }
          }
        } 
        else if (animState === 'CLOSING') {
          const k = Math.min(t / closeTime, 1);
          const e = easeInOut(k);
          topGroup.position.y = openDistance * (1 - e);
          botGroup.position.y = -openDistance * (1 - e);
          
          if (k >= 1) {
            playing = false;
            reset();
          }
        }
      }

      // --- Particle Integration (Physics changes based on state) ---
      const drag = 0.96;
      const swirlForce = 2.0;
      const springStrength = 1.5; // <-- NEW: Y-axis spring
      const pullStrength = 2.0;

      for (let i = 0; i < particleCount; i++) {
        if (life[i] < 1) {
          let x = positions[i*3];
          let y = positions[i*3+1];
          let z = positions[i*3+2];
          let vx = velocities[i*3];
          let vy = velocities[i*3+1];
          let vz = velocities[i*3+2];
          
          if (animState === 'REVERSING') {
            // "Pack-in" physics
            vx -= x * pullStrength * dt;
            vy -= y * pullStrength * dt;
            vz -= z * pullStrength * dt;
            
            if (x*x + y*y + z*z < 0.01) { life[i] = 1; }
          } 
          else if (animState === 'OPENING' || animState === 'SWIRLING') {
            // "Helix Swirl" physics
            const radius = Math.sqrt(x*x + z*z);
            if (radius > 0.01) {
              vx += (-z / radius) * swirlForce * dt; // Tangential force (swirl)
              vz += (x / radius) * swirlForce * dt;
            }
            vy -= y * springStrength * dt; // <-- NEW: Spring force pulls back to y=0
            
            life[i] += dt * 0.20;
            if (life[i] >= 1) { life[i]=1; } 
          }
          
          vx *= drag;
          vy *= drag;
          vz *= drag;
          
          positions[i*3] = x + vx * dt;
          positions[i*3+1] = y + vy * dt;
          positions[i*3+2] = z + vz * dt;
          
          velocities[i*3] = vx;
          velocities[i*3+1] = vy;
          velocities[i*3+2] = vz;
        }
      }
      pGeo.attributes.position.needsUpdate = true;
      pGeo.attributes.aLife.needsUpdate = true;
      
      renderer.render(scene, camera);
    }
    loop(performance.now());
  })();
  </script>
</body>
</html>
