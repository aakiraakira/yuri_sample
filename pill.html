<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Capsule — Transparent, Swirl & Return</title>
  <style>
    html,body{height:100%;margin:0;background:transparent}
    #scene{position:fixed;inset:0;background:transparent;pointer-events:none;}
    .ui{position:fixed;inset:auto 0 24px 0;display:flex;justify-content:center;gap:10px;pointer-events:auto}
    .btn{font:600 14px/1.1 Inter,system-ui,Arial;padding:12px 16px;border-radius:12px;border:0;background:#151515;color:#fff;box-shadow:0 6px 20px rgba(0,0,0,.25);cursor:pointer}
    .btn:active{transform:translateY(1px)}
  </style>
</head>
<body>
  <div id="scene"></div>
  <div class="ui">
    <button id="play" class="btn">Play once</button>
    <button id="replay" class="btn">Replay</button>
  </div>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script>
  (() => {
    // ---------- Renderer ----------
    const host = document.getElementById('scene');
    const scene = new THREE.Scene();

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.setClearColor(0x000000, 0);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.15;
    renderer.physicallyCorrectLights = true;
    host.appendChild(renderer.domElement);

    // ---------- Camera ----------
    const camera = new THREE.PerspectiveCamera(28, innerWidth/innerHeight, 0.1, 200);
    scene.add(camera);
    function fitCameraToHeight(worldHeight, margin=1.12){
      const h = worldHeight*margin;
      const dist = (h*0.5)/Math.tan(THREE.MathUtils.degToRad(camera.fov*0.5));
      camera.position.set(0, 0.25, dist);
      camera.lookAt(0,0,0);
      camera.updateProjectionMatrix();
    }
    addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      fitCameraToHeight(totalHeight);
    });

    // ---------- Lights ----------
    scene.add(new THREE.HemisphereLight(0xffffff, 0x141414, 0.7));
    const key = new THREE.DirectionalLight(0xffffff, 1.25); key.position.set(2.6,3.8,6.3); scene.add(key);
    const fill= new THREE.DirectionalLight(0xffffff, 0.55); fill.position.set(-3.6,1.2,3.4); scene.add(fill);
    const rim = new THREE.DirectionalLight(0xffffff, 0.75); rim.position.set(-2.2,2.0,-5.6); scene.add(rim);

    // ---------- Materials (shades of #8b0000) ----------
    const RED_BASE = 0x8b0000; // outer top
    const RED_MID  = 0x780000; // outer bottom
    const RED_DARK = 0x5c0000; // inner + bevel

    function makeShellMat(hex, extra={}) {
      return new THREE.MeshPhysicalMaterial({
        color: hex,
        roughness: 0.18,
        metalness: 0.0,
        transparent: true,
        opacity: 1.0,
        transmission: 0.93,           // very transparent
        ior: 1.45,
        thickness: 0.35,              // thinner glass feel
        attenuationColor: new THREE.Color(0x8b0000),
        attenuationDistance: 7.5,     // less color absorption through the wall
        clearcoat: 0.9,
        clearcoatRoughness: 0.08,
        reflectivity: 0.55,
        side: THREE.DoubleSide,
        ...extra
      });
    }

    const matTopOuter = makeShellMat(RED_BASE);
    const matBotOuter = makeShellMat(RED_MID);
    const matInner    = makeShellMat(RED_DARK, { roughness:0.24, transmission:0.96, thickness:0.28 });

    // ---------- Capsule geometry (hollow with rounded lip; NO flat rings) ----------
    const r = 1.2;           // outer radius
    const wall = 0.08;       // thinner wall to avoid heavy banding
    const halfCyl = 2.0;
    const openDistance = 2.8;

    const topGroup = new THREE.Group();
    const botGroup = new THREE.Group();
    scene.add(topGroup, botGroup);

    const segs = 80;

    // Top half — outer
    const topOuterCyl = new THREE.Mesh(new THREE.CylinderGeometry(r, r, halfCyl, segs, 1, true), matTopOuter);
    topOuterCyl.position.y = halfCyl/2; topGroup.add(topOuterCyl);
    const topOuterHem = new THREE.Mesh(new THREE.SphereGeometry(r, segs, 48, 0, Math.PI*2, 0, Math.PI/2), matTopOuter);
    topOuterHem.position.y = halfCyl; topGroup.add(topOuterHem);

    // Top half — inner
    const topInnerCyl = new THREE.Mesh(new THREE.CylinderGeometry(r-wall, r-wall, halfCyl, segs, 1, true), matInner);
    topInnerCyl.position.y = halfCyl/2; topGroup.add(topInnerCyl);
    const topInnerHem = new THREE.Mesh(new THREE.SphereGeometry(r-wall, segs, 48, 0, Math.PI*2, 0, Math.PI/2), matInner);
    topInnerHem.position.y = halfCyl; topGroup.add(topInnerHem);

    // Rounded lip (torus bevel) – avoids the flat “disc” look
    const lipTop = new THREE.Mesh(new THREE.TorusGeometry(r - wall*0.5, wall*0.46, 14, 88), matInner);
    lipTop.rotation.x = Math.PI/2;
    lipTop.position.y = 0.0 + 0.001;
    topGroup.add(lipTop);

    // Bottom half — outer
    const botOuterCyl = new THREE.Mesh(new THREE.CylinderGeometry(r, r, halfCyl, segs, 1, true), matBotOuter);
    botOuterCyl.position.y = -halfCyl/2; botGroup.add(botOuterCyl);
    const botOuterHem = new THREE.Mesh(new THREE.SphereGeometry(r, segs, 48, 0, Math.PI*2, Math.PI/2, Math.PI/2), matBotOuter);
    botOuterHem.position.y = -halfCyl; botGroup.add(botOuterHem);

    // Bottom half — inner
    const botInnerCyl = new THREE.Mesh(new THREE.CylinderGeometry(r-wall, r-wall, halfCyl, segs, 1, true), matInner);
    botInnerCyl.position.y = -halfCyl/2; botGroup.add(botInnerCyl);
    const botInnerHem = new THREE.Mesh(new THREE.SphereGeometry(r-wall, segs, 48, 0, Math.PI*2, Math.PI/2, Math.PI/2), matInner);
    botInnerHem.position.y = -halfCyl; botGroup.add(botInnerHem);

    // Bottom rounded lip
    const lipBot = new THREE.Mesh(new THREE.TorusGeometry(r - wall*0.5, wall*0.46, 14, 88), matInner);
    lipBot.rotation.x = Math.PI/2;
    lipBot.position.y = -0.0 - 0.001;
    botGroup.add(lipBot);

    // Closed start
    topGroup.position.y = 0;
    botGroup.position.y = 0;

    // Fit camera
    const totalHeight = (halfCyl*2 + r*2) + openDistance*2 + 2.0;
    fitCameraToHeight(totalHeight);

    // ---------- Particles (dense swirl + return) ----------
    const particleCount = 12000;
    const pGeo = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount*3);
    const velocities = new Float32Array(particleCount*3);
    const life = new Float32Array(particleCount);

    for (let i=0;i<particleCount;i++){
      positions[i*3] = positions[i*3+1] = positions[i*3+2] = 0;
      velocities[i*3] = velocities[i*3+1] = velocities[i*3+2] = 0;
      life[i] = 1; // dead
    }

    pGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    pGeo.setAttribute('aLife', new THREE.BufferAttribute(life, 1));

    const pMat = new THREE.PointsMaterial({
      color: 0x7A1C1C,
      size: 0.05,
      sizeAttenuation: true,
      transparent: true,
      opacity: 0.95,
      depthWrite: false
    });

    const points = new THREE.Points(pGeo, pMat);
    scene.add(points);

    function spawnBurst(count, radius=0.06, speed=2.0){
      let spawned = 0;
      for (let i=0;i<particleCount && spawned<count;i++){
        if (life[i] >= 1){
          const u = Math.random(), v = Math.random();
          const theta = 2*Math.PI*u;
          const phi = Math.acos(2*v - 1);
          const rr = radius*Math.cbrt(Math.random());
          const x = rr*Math.sin(phi)*Math.cos(theta);
          const y = rr*Math.cos(phi);
          const z = rr*Math.sin(phi)*Math.sin(theta);
          const dir = new THREE.Vector3(x, y*0.42, z).normalize();

          positions[i*3]   = x;
          positions[i*3+1] = y;
          positions[i*3+2] = z;

          const vmag = speed*(0.7+Math.random()*0.9);
          velocities[i*3]   = dir.x*vmag;
          velocities[i*3+1] = dir.y*vmag;
          velocities[i*3+2] = dir.z*vmag;

          life[i] = 0;
          spawned++;
        }
      }
      pGeo.attributes.position.needsUpdate = true;
      pGeo.attributes.aLife.needsUpdate = true;
    }

    // ---------- Timeline ----------
    let playing = false, t = 0;

    const openDelay = 0.8;
    const openTime  = 2.2;  // slower & smoother
    const flowTime  = 3.0;  // swirl time
    const suckTime  = 2.2;  // suction active
    const closeTime = 2.2;  // smooth close
    const totalTime = openDelay + openTime + flowTime + suckTime + closeTime + 0.5;

    const smooth = x => (x<=0?0:x>=1?1:(x*x*x*(x*(x*6-15)+10))); // quintic

    function reset(){
      t = 0;
      topGroup.position.y = 0;
      botGroup.position.y = 0;
      for (let i=0;i<particleCount;i++){
        life[i]=1;
        velocities[i*3]=velocities[i*3+1]=velocities[i*3+2]=0;
      }
      pGeo.attributes.aLife.needsUpdate = true;
      playing = false;
    }
    function play(){ reset(); playing = true; }

    document.getElementById('play').onclick = play;
    document.getElementById('replay').onclick = play;
    setTimeout(play, 400);

    // ---------- Loop ----------
    let last = performance.now();
    function loop(now){
      requestAnimationFrame(loop);
      const dt = Math.min((now-last)/1000, 0.033);
      last = now;

      if (playing){
        t += dt;

        const tOpenStart = openDelay;
        const tOpenEnd   = tOpenStart + openTime;
        const tFlowEnd   = tOpenEnd + flowTime;
        const tSuckEnd   = tFlowEnd + suckTime;
        const tCloseEnd  = tSuckEnd + closeTime;

        // Opening
        if (t >= tOpenStart){
          const kO = smooth(Math.min((t - tOpenStart)/openTime, 1));
          topGroup.position.y = kO*openDistance;
          botGroup.position.y = -kO*openDistance;
        }

        // Emit while opening + flow
        if (t > tOpenStart + 0.2 && t < tFlowEnd){
          spawnBurst(520); // denser
        }

        // Closing (starts after flow; suction overlaps)
        if (t > tFlowEnd){
          const kC = smooth(Math.min((t - tFlowEnd)/closeTime, 1));
          const d = (1 - kC)*openDistance;
          topGroup.position.y = d;
          botGroup.position.y = -d;
        }

        if (t >= tCloseEnd || t >= totalTime) playing = false;
      }

      // Particle dynamics
      const drag = 0.986;
      const inFlow   = (t > openDelay) && (t < (openDelay+openTime+flowTime));
      const suction  = (t >= (openDelay+openTime+flowTime)); // during suck+close
      const swirlGain = inFlow ? 1.15 : 0.55;
      const suctionGain = suction ? 2.6 : 0.0;

      for (let i=0;i<particleCount;i++){
        if (life[i] < 1){
          const ix = i*3;
          let x=positions[ix], y=positions[ix+1], z=positions[ix+2];

          // Swirl around Y axis (vortex)
          const rXZ = Math.max(0.0001, Math.hypot(x,z));
          const tx = (-z / rXZ);
          const tz = ( x / rXZ);
          const swirl = swirlGain*(0.85 + 0.15*Math.random());
          velocities[ix]   += tx*swirl*dt;
          velocities[ix+2] += tz*swirl*dt;

          // Mild gravity
          velocities[ix+1] += -0.24*dt;

          // Suction towards center (return)
          if (suction){
            const toX=-x, toY=-y, toZ=-z;
            const dist = Math.max(0.0001, Math.hypot(toX,toY,toZ));
            const s = suctionGain*dt;
            velocities[ix]   += (toX/dist)*s;
            velocities[ix+1] += (toY/dist)*s;
            velocities[ix+2] += (toZ/dist)*s;

            // Absorb back inside
            if (dist < 0.12){
              life[i] = 1;
              velocities[ix]=velocities[ix+1]=velocities[ix+2]=0;
              continue;
            }
          }

          // Integrate + turbulence + drag
          positions[ix]   += velocities[ix]*dt;
          positions[ix+1] += velocities[ix+1]*dt;
          positions[ix+2] += velocities[ix+2]*dt;

          velocities[ix]   += (Math.random()-0.5)*0.06*dt;
          velocities[ix+1] += (Math.random()-0.5)*0.05*dt;
          velocities[ix+2] += (Math.random()-0.5)*0.06*dt;

          velocities[ix]*=drag; velocities[ix+1]*=drag; velocities[ix+2]*=drag;

          // safety fade if lingering long after
          if (!suction){ life[i] += dt*0.18; if (life[i] >= 1) life[i]=1; }
        }
      }
      pGeo.attributes.position.needsUpdate = true;

      renderer.render(scene, camera);
    }
    loop(performance.now());
  })();
  </script>
</body>
</html>
